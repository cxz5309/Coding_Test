# 입실 퇴실

## 문제

사회적 거리두기를 위해 회의실에 출입할 때 명부에 이름을 적어야 합니다. 입실과 퇴실이 동시에 이뤄지는 경우는 없으며, 입실 시각과 퇴실 시각은 따로 기록하지 않습니다.  

오늘 회의실에는 총 n명이 입실 후 퇴실했습니다. 편의상 사람들은 1부터 n까지 번호가 하나씩 붙어있으며, 두 번 이상 회의실에 들어온 사람은 없습니다. 이때, 각 사람별로 반드시 만난 사람은 몇 명인지 구하려 합니다.  
예를 들어 입실 명부에 기재된 순서가 [1, 3, 2], 퇴실 명부에 기재된 순서가 [1, 2, 3]인 경우,  

- 1번과 2번은 만났는지 알 수 없습니다.
- 1번과 3번은 만났는지 알 수 없습니다.
- 2번과 3번은 반드시 만났습니다.

또 다른 예로 입실 순서가 [1, 4, 2, 3], 퇴실 순서가 [2, 1, 3, 4]인 경우,  

- 1번과 2번은 반드시 만났습니다.
- 1번과 3번은 만났는지 알 수 없습니다.
- 1번과 4번은 반드시 만났습니다.
- 2번과 3번은 만났는지 알 수 없습니다.
- 2번과 4번은 반드시 만났습니다.
- 3번과 4번은 반드시 만났습니다.

회의실에 입실한 순서가 담긴 정수 배열 enter, 퇴실한 순서가 담긴 정수 배열 leave가 매개변수로 주어질 때, 각 사람별로 반드시 만난 사람은 몇 명인지 번호 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.  


## 제한 

- 1 ≤ enter의 길이 ≤ 1,000
- 1 ≤ enter의 원소 ≤ enter의 길이
  - 모든 사람의 번호가 중복없이 하나씩 들어있습니다.
- leave의 길이 = enter의 길이
- 1 ≤ leave의 원소 ≤ leave의 길이
  - 모든 사람의 번호가 중복없이 하나씩 들어있습니다.

## 입출력 예

input
``` 
[1,3,2]	[1,2,3]
```
output
``` 
[0,1,1]
```


## 입출력 예 설명

- 입출력 예 #1

만약, 다음과 같이 회의실에 입실, 퇴실했다면

|회의실	|설명|
|---|---|
|[1]	|1번 입실|
|[1, 3]	|3번 입실|
|[3]	|1번 퇴실|
|[2, 3]	|2번 입실|
|[3]	|2번 퇴실|
|[]	|3번 퇴실|

- 1번과 2번은 만나지 않습니다.
- 1번과 3번은 만납니다
- 2번과 3번은 만납니다.

만약, 다음과 같이 회의실에 입실, 퇴실했다면

|회의실	|설명|
|---|---|
|[1]	|1번 입실|
|[]	|1번 퇴실|
|[3]	|3번 입실|
|[2, 3]	|2번 입실|
|[3]	|2번 퇴실|
|[]	|3번 퇴실|
- 1번과 2번은 만나지 않습니다.
- 1번과 3번은 만나지 않습니다.
- 2번과 3번은 만납니다.
위 방법 외에 다른 순서로 입실, 퇴실 할 경우 1번과 2번이 만나도록 할 수도 있습니다. 하지만 2번과 3번이 만나지 않도록 하는 방법은 없습니다.  
따라서  
- 1번과 2번은 만났는지 알 수 없습니다.
- 1번과 3번은 만났는지 알 수 없습니다.
- 2번과 3번은 반드시 만났습니다.



## (안할 확률이 높은) 알고리즘 설명
- 최악의 상황(가장 적게 만나는 상황) : 무조건 들어오자마자 나가는 상황
- 최악의 상황에서도 만나게 되는 사람이 정답 숫자
- 머리가 안되서 시뮬레이션으로 풀었다
- 이미 들어와있던 사람이 안 나가고 있는 상태에서 새로운 사람이 계속 교체되면 hashMap의 size 최대값보다 커질 수 있기 때문에 지속적으로 hashMap 전체를 바꿔주어야 한다는 것을 간과해서 이 방법으로 풀었다.
-  하나 들어올 때마다 hashMap 전체를 다 돌면서 초기화해주기 때문에 아마 꽤 느리다 (시간복잡도 O(n^2) 정도 될듯) 
- index를 이용해서 계산하는 더 빠른 방법도 있을 것이라고 생각한다.

